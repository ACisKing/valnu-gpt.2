CWE,Name,Description,Detection_Methods,Potential_Mitigations
CWE-787,Out-of-bounds ,"The product writes data past the end, or before the beginning, of the intended buffer."," Automated Static Analysis This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives.  Automated static analysis generally does not account for environmental considerations when reporting out-of-bounds memory operations. This can make it difficult for users to determine which warnings should be investigated first. For example, an analysis tool might report buffer overflows that originate from command line arguments in a program that is not expected to run with setuid or other special privileges.  Effectiveness: HighNote: Detection techniques for buffer-related errors are more mature than for most other weakness types.
 Automated Dynamic AnalysisThis weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.","Potential Mitigations
Phase:  RequirementsStrategy:  Language Selection Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.  
Phase:  Architecture and DesignStrategy:  Libraries or Frameworks Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.  Note: This is not a complete solution, since many buffer overflows are not related to strings.This is not necessarily a complete solution, since these mechanisms only detect certain types of overflows. In addition, the result is still a denial of service, since the typical response is to exit the application. 

Phase:  Implementation Consider adhering to the following rules when allocating and managing an application's memory:   Double check that the buffer is as large as specified.  When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.  Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.  If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.   
Phases:  Operation; Build and CompilationStrategy:  Environment Hardening Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].  Effectiveness: Defense in DepthNote: These techniques do not provide a complete solution. For instance, exploits frequently use a bug that discloses memory addresses in order to maximize reliability of code execution [REF-1337]. It has also been shown that a side-channel attack can bypass ASLR [REF-1333] 
Phase:  OperationStrategy:  Environment Hardening Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.  For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].  Effectiveness: Defense in DepthNote: This is not a complete solution, since buffer overflows could be used to overwrite nearby variables to modify the software's state in dangerous ways. In addition, it cannot be used in cases in which self-modifying code is required. Finally, an attack could still cause a denial of service, since the typical response is to exit the application. 
Phase:  ImplementationReplace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available. Effectiveness: ModerateNote: This approach is still susceptible to calculation errors, including issues such as off-by-one errors (CWE-193) and incorrectly calculating buffer lengths (CWE-131)."
CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,"Detection Methods
 Automated Static AnalysisUse automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible, especially when multiple components are involved. Effectiveness: Moderate
 Black BoxUse the XSS Cheat Sheet [REF-714] or automated test-generation tools to help launch a wide variety of attacks against your web application. The Cheat Sheet contains many subtle XSS variations that are specifically targeted against weak XSS defenses. Effectiveness: ModerateNote: With Stored XSS, the indirection caused by the data store can make it more difficult to find the problem. The tester must first inject the XSS string into the data store, then find the appropriate application functionality in which the XSS string is sent to other users of the application. These are two distinct steps in which the activation of the XSS can take place minutes, hours, or days after the XSS was originally injected into the data store.","Potential Mitigations
Phase:  Architecture and DesignStrategy:  Libraries or Frameworks Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.  Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.  
Phases:  Implementation; Architecture and Design Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.  For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters.  Parts of the same output document may require different encodings, which will vary depending on whether the output is in the:   HTML body  Element attributes (such as src=""XYZ"")  URIs  JavaScript sections  Cascading Style Sheets and style property   etc. Note that HTML Entity Encoding is only appropriate for the HTML body.  Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.  
Phases:  Architecture and Design; ImplementationStrategy:  Attack Surface ReductionUnderstand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls. Effectiveness: LimitedNote: This technique has limited effectiveness, but can be helpful when it is possible to store client state and sensitive information on the server side instead of in cookies, headers, hidden form fields, etc.
Phase:  Architecture and DesignFor any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server. 
Phase:  Architecture and DesignStrategy:  ParameterizationIf available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated. 
Phase:  ImplementationStrategy:  Output Encoding Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.  The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.  
Phase:  ImplementationWith Struts, write all data from form beans with the bean's filter attribute set to true. 
Phase:  ImplementationStrategy:  Attack Surface ReductionTo help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set. Effectiveness: Defense in Depth
Phase:  ImplementationStrategy:  Input Validation Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""  Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.  When dynamically constructing web pages, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. All input should be validated and cleansed, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. It is common to see data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing XSS, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent XSS, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, in a chat application, the heart emoticon (""<3"") would likely pass the validation step, since it is commonly used. However, it cannot be directly inserted into the web page because it contains the ""<"" character, which would need to be escaped or otherwise handled. In this case, stripping the ""<"" might reduce the risk of XSS, but it would produce incorrect behavior because the emoticon would not be recorded. This might seem to be a minor inconvenience, but it would be more important in a mathematical forum that wants to represent inequalities.  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.  Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.  
Phase:  Architecture and DesignStrategy:  Enforcement by ConversionWhen the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs. 
Phase:  OperationStrategy:  FirewallUse an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth. Effectiveness: ModerateNote: An application firewall might not cover all possible input vectors. In addition, attack techniques might be available to bypass the protection mechanism, such as using malformed inputs that can still be processed by the component that receives those inputs. Depending on functionality, an application firewall might inadvertently reject or modify legitimate requests. Finally, some manual effort may be required for customization.
Phases:  Operation; ImplementationStrategy:  Environment HardeningWhen using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues."
CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.","Detection Methods
 Automated Static Analysis This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives.  Automated static analysis might not be able to recognize when proper input validation is being performed, leading to false positives - i.e., warnings that do not have any security consequences or do not require any code changes.  Automated static analysis might not be able to detect the usage of custom API functions or third-party libraries that indirectly invoke SQL commands, leading to false negatives - especially if the API/library code is not available for analysis.  Note: This is not a perfect solution, since 100% accuracy and coverage are not feasible.
 Automated Dynamic AnalysisThis weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results. Effectiveness: Moderate
 Manual AnalysisManual analysis can be useful for finding this weakness, but it might not achieve desired code coverage within limited time constraints. This becomes difficult for weaknesses that must be considered for all inputs, since the attack surface can be too large. 
 Automated Static Analysis - Binary or Bytecode According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Bytecode Weakness Analysis - including disassembler + source code weakness analysis  Binary Weakness Analysis - including disassembler + source code weakness analysis    Effectiveness: High
 Dynamic Analysis with Automated Results Interpretation According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Database Scanners   Cost effective for partial coverage:   Web Application Scanner  Web Services Scanner    Effectiveness: High
 Dynamic Analysis with Manual Results Interpretation According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Fuzz Tester  Framework-based Fuzzer    Effectiveness: SOAR Partial
 Manual Static Analysis - Source Code According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Manual Source Code Review (not inspections)   Cost effective for partial coverage:   Focused Manual Spotcheck - Focused manual analysis of source    Effectiveness: High
 Automated Static Analysis - Source Code According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Source code Weakness Analyzer  Context-configured Source Code Weakness Analyzer    Effectiveness: High
 Architecture or Design Review According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Formal Methods / Correct-By-Construction   Cost effective for partial coverage:   Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)    Effectiveness: High","Potential Mitigations
Phase:  Architecture and DesignStrategy:  Libraries or Frameworks Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.  For example, consider using persistence layers such as Hibernate or Enterprise Java Beans, which can provide significant protection against SQL injection if used properly.  
Phase:  Architecture and DesignStrategy:  Parameterization If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.  Process SQL queries using prepared statements, parameterized queries, or stored procedures. These features should accept parameters or variables and support strong typing. Do not dynamically construct and execute query strings within these features using ""exec"" or similar functionality, since this may re-introduce the possibility of SQL injection. [REF-867]  
Phases:  Architecture and Design; OperationStrategy:  Environment Hardening Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.  Specifically, follow the principle of least privilege when creating user accounts to a SQL database. The database users should only have the minimum privileges necessary to use their account. If the requirements of the system indicate that a user can read and modify their own data, then limit their privileges so they cannot read/write others' data. Use the strictest permissions possible on all database objects, such as execute-only for stored procedures.  
Phase:  Architecture and DesignFor any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server. 
Phase:  ImplementationStrategy:  Output Encoding While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88).  Instead of building a new implementation, such features may be available in the database or programming language. For example, the Oracle DBMS_ASSERT package can check or enforce that parameters have certain properties that make them less vulnerable to SQL injection. For MySQL, the mysql_real_escape_string() API function is available in both C and PHP.  
Phase:  ImplementationStrategy:  Input Validation Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""  Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.  When constructing SQL query strings, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping.  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing SQL injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent SQL injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, the name ""O'Reilly"" would likely pass the validation step, since it is a common last name in the English language. However, it cannot be directly inserted into the database because it contains the ""'"" apostrophe character, which would need to be escaped or otherwise handled. In this case, stripping the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded.  When feasible, it may be safest to disallow meta-characters entirely, instead of escaping them. This will provide some defense in depth. After the data is entered into the database, later processes may neglect to escape meta-characters before use, and you may not have control over those processes.  
Phase:  Architecture and DesignStrategy:  Enforcement by ConversionWhen the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs. 
Phase:  Implementation Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success.  If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files.  Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not.  In the context of SQL Injection, error messages revealing the structure of a SQL query can help attackers tailor successful attack strings.  
Phase:  OperationStrategy:  FirewallUse an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth. Effectiveness: ModerateNote: An application firewall might not cover all possible input vectors. In addition, attack techniques might be available to bypass the protection mechanism, such as using malformed inputs that can still be processed by the component that receives those inputs. Depending on functionality, an application firewall might inadvertently reject or modify legitimate requests. Finally, some manual effort may be required for customization.
Phases:  Operation; ImplementationStrategy:  Environment HardeningWhen using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues."
CWE-416,Use After Free,"Referencing memory after it has been freed can cause a program to crash, use unexpected values, or execute code.","Detection Methods
 FuzzingFuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues. Effectiveness: High
 Automated Static AnalysisAutomated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect ""sources"" (origins of input) with ""sinks"" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) Effectiveness: High","Potential Mitigations
Phase:  Architecture and DesignChoose a language that provides automatic memory management. 
Phase:  ImplementationWhen freeing pointers, be sure to set them to NULL once they are freed. However, the utilization of multiple or complex data structures may lower the usefulness of this strategy."
CWE-78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection'),"The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.","Detection Methods
 Automated Static Analysis This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives.  Automated static analysis might not be able to recognize when proper input validation is being performed, leading to false positives - i.e., warnings that do not have any security consequences or require any code changes.  Automated static analysis might not be able to detect the usage of custom API functions or third-party libraries that indirectly invoke OS commands, leading to false negatives - especially if the API/library code is not available for analysis.  Note: This is not a perfect solution, since 100% accuracy and coverage are not feasible.
 Automated Dynamic AnalysisThis weakness can be detected using dynamic tools and techniques that interact with the product using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The product's operation may slow down, but it should not become unstable, crash, or generate incorrect results. Effectiveness: Moderate
 Manual Static AnalysisSince this weakness does not typically appear frequently within a single software package, manual white box techniques may be able to provide sufficient code coverage and reduction of false positives if all potentially-vulnerable operations can be assessed within limited time constraints. Effectiveness: High
 Automated Static Analysis - Binary or Bytecode According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Bytecode Weakness Analysis - including disassembler + source code weakness analysis  Binary Weakness Analysis - including disassembler + source code weakness analysis    Effectiveness: High
 Dynamic Analysis with Automated Results Interpretation According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Web Application Scanner  Web Services Scanner  Database Scanners    Effectiveness: SOAR Partial
 Dynamic Analysis with Manual Results Interpretation According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Fuzz Tester  Framework-based Fuzzer    Effectiveness: SOAR Partial
 Manual Static Analysis - Source Code According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Manual Source Code Review (not inspections)   Cost effective for partial coverage:   Focused Manual Spotcheck - Focused manual analysis of source    Effectiveness: High
 Automated Static Analysis - Source Code According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Source code Weakness Analyzer  Context-configured Source Code Weakness Analyzer    Effectiveness: High
 Architecture or Design Review According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Formal Methods / Correct-By-Construction   Cost effective for partial coverage:   Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)    Effectiveness: High","Potential Mitigations
Phase:  Architecture and DesignIf at all possible, use library calls rather than external processes to recreate the desired functionality. 
Phases:  Architecture and Design; OperationStrategy:  Sandbox or Jail Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.  Be careful to avoid CWE-243 and other weaknesses related to jails.  Effectiveness: LimitedNote: The effectiveness of this mitigation depends on the prevention capabilities of the specific sandbox or jail being used and might only help to reduce the scope of an attack, such as restricting the attacker to certain system calls or limiting the portion of the file system that can be accessed.
Phase:  Architecture and DesignStrategy:  Attack Surface ReductionFor any data that will be used to generate a command to be executed, keep as much of that data out of external control as possible. For example, in web applications, this may require storing the data locally in the session's state instead of sending it out to the client in a hidden form field. 
Phase:  Architecture and DesignFor any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server. 
Phase:  Architecture and DesignStrategy:  Libraries or Frameworks Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.  For example, consider using the ESAPI Encoding control [REF-45] or a similar tool, library, or framework. These will help the programmer encode outputs in a manner less prone to error.  
Phase:  ImplementationStrategy:  Output EncodingWhile it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88). 
Phase:  ImplementationIf the program to be executed allows arguments to be specified within an input file or from standard input, then consider using that mode to pass arguments instead of the command line. 
Phase:  Architecture and DesignStrategy:  Parameterization If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.  Some languages offer multiple functions that can be used to invoke commands. Where possible, identify any function that invokes a command shell using a single string, and replace it with a function that requires individual arguments. These functions typically perform appropriate quoting and filtering of arguments. For example, in C, the system() function accepts a string that contains the entire command to be executed, whereas execl(), execve(), and others require an array of strings, one for each argument. In Windows, CreateProcess() only accepts one command at a time. In Perl, if system() is provided with an array of arguments, then it will quote each of the arguments.  
Phase:  ImplementationStrategy:  Input Validation Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""  Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.  When constructing OS command strings, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping.  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing OS command injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent OS command injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, when invoking a mail program, you might need to allow the subject field to contain otherwise-dangerous inputs like "";"" and "">"" characters, which would need to be escaped or otherwise handled. In this case, stripping the character might reduce the risk of OS command injection, but it would produce incorrect behavior because the subject field would not be recorded as the user intended. This might seem to be a minor inconvenience, but it could be more important when the program relies on well-structured subject lines in order to pass messages to other components.  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.  
Phase:  Architecture and DesignStrategy:  Enforcement by ConversionWhen the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs. 
Phase:  OperationStrategy:  Compilation or Build HardeningRun the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184). 
Phase:  OperationStrategy:  Environment HardeningRun the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184). 
Phase:  Implementation Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success.  If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files.  Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not.  In the context of OS Command Injection, error information passed back to the user might reveal whether an OS command is being executed and possibly which command is being used.  
Phase:  OperationStrategy:  Sandbox or JailUse runtime policy enforcement to create an allowlist of allowable commands, then prevent use of any command that does not appear in the allowlist. Technologies such as AppArmor are available to do this. 
Phase:  OperationStrategy:  FirewallUse an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth. Effectiveness: ModerateNote: An application firewall might not cover all possible input vectors. In addition, attack techniques might be available to bypass the protection mechanism, such as using malformed inputs that can still be processed by the component that receives those inputs. Depending on functionality, an application firewall might inadvertently reject or modify legitimate requests. Finally, some manual effort may be required for customization.
Phases:  Architecture and Design; OperationStrategy:  Environment HardeningRun your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations. 
Phases:  Operation; ImplementationStrategy:  Environment HardeningWhen using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues."
CWE-20,Improper Input Validation,"The product receives input or data, but it does not validate or incorrectly validates that the input has the properties that are required to process the data safely and correctly.","Detection Methods
 Automated Static Analysis Some instances of improper input validation can be detected using automated static analysis.  A static analysis tool might allow the user to specify which application-specific methods or functions perform input validation; the tool might also have built-in knowledge of validation frameworks such as Struts. The tool may then suppress or de-prioritize any associated warnings. This allows the analyst to focus on areas of the software in which input validation does not appear to be present.  Except in the cases described in the previous paragraph, automated static analysis might not be able to recognize when proper input validation is being performed, leading to false positives - i.e., warnings that do not have any security consequences or require any code changes.  
 Manual Static AnalysisWhen custom input validation is required, such as when enforcing business rules, manual analysis is necessary to ensure that the validation is properly implemented. 
 FuzzingFuzzing techniques can be useful for detecting input validation errors. When unexpected inputs are provided to the software, the software should not crash or otherwise become unstable, and it should generate application-controlled error messages. If exceptions or interpreter-generated error messages occur, this indicates that the input was not detected and handled within the application logic itself. 
 Automated Static Analysis - Binary or Bytecode According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Bytecode Weakness Analysis - including disassembler + source code weakness analysis  Binary Weakness Analysis - including disassembler + source code weakness analysis    Effectiveness: SOAR Partial
 Manual Static Analysis - Binary or Bytecode According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies    Effectiveness: SOAR Partial
 Dynamic Analysis with Automated Results Interpretation According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Web Application Scanner  Web Services Scanner  Database Scanners    Effectiveness: High
 Dynamic Analysis with Manual Results Interpretation According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Fuzz Tester  Framework-based Fuzzer   Cost effective for partial coverage:   Host Application Interface Scanner  Monitored Virtual Environment - run potentially malicious code in sandbox / wrapper / virtual machine, see if it does anything suspicious    Effectiveness: High
 Manual Static Analysis - Source Code According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Focused Manual Spotcheck - Focused manual analysis of source  Manual Source Code Review (not inspections)    Effectiveness: High
 Automated Static Analysis - Source Code According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Source code Weakness Analyzer  Context-configured Source Code Weakness Analyzer    Effectiveness: High
 Architecture or Design Review According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)  Formal Methods / Correct-By-Construction   Cost effective for partial coverage:   Attack Modeling    Effectiveness: High","Potential Mitigations
Phase:  Architecture and DesignStrategy:  Attack Surface ReductionConsider using language-theoretic security (LangSec) techniques that characterize inputs using a formal language and build ""recognizers"" for that language. This effectively requires parsing to be a distinct layer that effectively enforces a boundary between raw input and internal data representations, instead of allowing parser code to be scattered throughout the program, where it could be subject to errors or inconsistencies that create weaknesses. [REF-1109] [REF-1110] [REF-1111] 
Phase:  Architecture and DesignStrategy:  Libraries or FrameworksUse an input validation framework such as Struts or the OWASP ESAPI Validation API. Note that using a framework does not automatically address all input validation problems; be mindful of weaknesses that could arise from misusing the framework itself (CWE-1173). 
Phases:  Architecture and Design; ImplementationStrategy:  Attack Surface ReductionUnderstand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls. 
Phase:  ImplementationStrategy:  Input Validation Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""  Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.  Effectiveness: High
Phase:  Architecture and Design For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.  Even though client-side checks provide minimal benefits with respect to server-side security, they are still useful. First, they can support intrusion detection. If the server receives input that should have been rejected by the client, then it may be an indication of an attack. Second, client-side error-checking can provide helpful feedback to the user about the expectations for valid input. Third, there may be a reduction in server-side processing time for accidental input errors, although this is typically a small savings.  
Phase:  ImplementationWhen your application combines data from multiple sources, perform the validation after the sources have been combined. The individual data elements may pass the validation step but violate the intended restrictions after they have been combined. 
Phase:  ImplementationBe especially careful to validate all input when invoking code that crosses language boundaries, such as from an interpreted language to native code. This could create an unexpected interaction between the language boundaries. Ensure that you are not violating any of the expectations of the language with which you are interfacing. For example, even though Java may not be susceptible to buffer overflows, providing a large argument in a call to native code might trigger an overflow. 
Phase:  ImplementationDirectly convert your input type into the expected data type, such as using a conversion function that translates a string into a number. After converting to the expected data type, ensure that the input's values fall within the expected range of allowable values and that multi-field consistencies are maintained. 
Phase:  Implementation Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180, CWE-181). Make sure that your application does not inadvertently decode the same input twice (CWE-174). Such errors could be used to bypass allowlist schemes by introducing dangerous inputs after they have been checked. Use libraries such as the OWASP ESAPI Canonicalization control.  Consider performing repeated canonicalization until your input does not change any more. This will avoid double-decoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properly-encoded dangerous content.  
Phase:  ImplementationWhen exchanging data between components, ensure that both components are using the same character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set the encoding you are using whenever the protocol allows you to do so."
CWE-125,Out-of-bounds Read,"The product reads data past the end, or before the beginning, of the intended buffer.","Detection Methods
 FuzzingFuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues. Effectiveness: High
 Automated Static AnalysisAutomated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect ""sources"" (origins of input) with ""sinks"" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) Effectiveness: High","Potential Mitigations
Phase:  ImplementationStrategy:  Input Validation Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""  Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.  To reduce the likelihood of introducing an out-of-bounds read, ensure that you validate and ensure correct calculations for any length argument, buffer size calculation, or offset. Be especially careful of relying on a sentinel (i.e. special character such as NUL) in untrusted inputs.  
Phase:  Architecture and DesignStrategy:  Language SelectionUse a language that provides appropriate memory abstractions."
CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.","Detection Methods
 Automated Static AnalysisAutomated techniques can find areas where path traversal weaknesses exist. However, tuning or customization may be required to remove or de-prioritize path-traversal problems that are only exploitable by the product's administrator - or other privileged users - and thus potentially valid behavior or, at worst, a bug instead of a vulnerability. Effectiveness: High
 Manual Static AnalysisManual white box techniques may be able to provide sufficient code coverage and reduction of false positives if all file access operations can be assessed within limited time constraints. Effectiveness: High
 Automated Static Analysis - Binary or Bytecode According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Bytecode Weakness Analysis - including disassembler + source code weakness analysis   Cost effective for partial coverage:   Binary Weakness Analysis - including disassembler + source code weakness analysis    Effectiveness: High
 Manual Static Analysis - Binary or Bytecode According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies    Effectiveness: SOAR Partial
 Dynamic Analysis with Automated Results Interpretation According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Web Application Scanner  Web Services Scanner  Database Scanners    Effectiveness: High
 Dynamic Analysis with Manual Results Interpretation According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Fuzz Tester  Framework-based Fuzzer    Effectiveness: High
 Manual Static Analysis - Source Code According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Manual Source Code Review (not inspections)   Cost effective for partial coverage:   Focused Manual Spotcheck - Focused manual analysis of source    Effectiveness: High
 Automated Static Analysis - Source Code According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Source code Weakness Analyzer  Context-configured Source Code Weakness Analyzer    Effectiveness: High
 Architecture or Design Review According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Formal Methods / Correct-By-Construction   Cost effective for partial coverage:   Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)    Effectiveness: High","Potential Mitigations
Phase:  ImplementationStrategy:  Input Validation Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""  Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.  When validating filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a single ""."" character in the filename to avoid weaknesses such as CWE-23, and exclude directory separators such as ""/"" to avoid CWE-36. Use a list of allowable file extensions, which will help to avoid CWE-434.  Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For example, filtering ""/"" is insufficient protection if the filesystem also supports the use of ""\"" as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE-182). For example, if ""../"" sequences are removed from the "".../...//"" string in a sequential fashion, two instances of ""../"" would be removed from the original string, but the remaining characters would still form the ""../"" string.  
Phase:  Architecture and DesignFor any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server. 
Phase:  ImplementationStrategy:  Input Validation Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked.  Use a built-in path canonicalization function (such as realpath() in C) that produces the canonical version of the pathname, which effectively removes "".."" sequences and symbolic links (CWE-23, CWE-59). This includes:   realpath() in C  getCanonicalPath() in Java  GetFullPath() in ASP.NET  realpath() or abs_path() in Perl  realpath() in PHP   
Phase:  Architecture and DesignStrategy:  Libraries or FrameworksUse a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. 
Phase:  OperationStrategy:  FirewallUse an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth. Effectiveness: ModerateNote: An application firewall might not cover all possible input vectors. In addition, attack techniques might be available to bypass the protection mechanism, such as using malformed inputs that can still be processed by the component that receives those inputs. Depending on functionality, an application firewall might inadvertently reject or modify legitimate requests. Finally, some manual effort may be required for customization.
Phases:  Architecture and Design; OperationStrategy:  Environment HardeningRun your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations. 
Phase:  Architecture and DesignStrategy:  Enforcement by Conversion When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.  For example, ID 1 could map to ""inbox.txt"" and ID 2 could map to ""profile.txt"". Features such as the ESAPI AccessReferenceMap [REF-185] provide this capability.  
Phases:  Architecture and Design; OperationStrategy:  Sandbox or Jail Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.  Be careful to avoid CWE-243 and other weaknesses related to jails.  Effectiveness: LimitedNote: The effectiveness of this mitigation depends on the prevention capabilities of the specific sandbox or jail being used and might only help to reduce the scope of an attack, such as restricting the attacker to certain system calls or limiting the portion of the file system that can be accessed.
Phases:  Architecture and Design; OperationStrategy:  Attack Surface Reduction Store library, include, and utility files outside of the web document root, if possible. Otherwise, store them in a separate directory and use the web server's access control capabilities to prevent attackers from directly requesting them. One common practice is to define a fixed constant in each calling program, then check for the existence of the constant in the library/include file; if the constant does not exist, then the file was directly requested, and it can exit immediately.  This significantly reduces the chance of an attacker being able to bypass any protection mechanisms that are in the base program but not in the include files. It will also reduce the attack surface.  
Phase:  Implementation Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success.  If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files.  Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not.  In the context of path traversal, error messages which disclose path information can help attackers craft the appropriate attack strings to move through the file system hierarchy.  
Phases:  Operation; ImplementationStrategy:  Environment HardeningWhen using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues."
CWE-352,Cross-Site Request Forgery (CSRF),"The web application does not, or can not, sufficiently verify whether a well-formed, valid, consistent request was intentionally provided by the user who submitted the request.","Detection Methods
 Manual Analysis This weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session.  Specifically, manual analysis can be useful for finding this weakness, and for minimizing false positives assuming an understanding of business logic. However, it might not achieve desired code coverage within limited time constraints. For black-box analysis, if credentials are not known for privileged accounts, then the most security-critical portions of the application may not receive sufficient attention.  Consider using OWASP CSRFTester to identify potential issues and aid in manual analysis.  Effectiveness: HighNote: These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.
 Automated Static AnalysisCSRF is currently difficult to detect reliably using automated techniques. This is because each application has its own implicit security policy that dictates which requests can be influenced by an outsider and automatically performed on behalf of a user, versus which requests require strong confidence that the user intends to make the request. For example, a keyword search of the public portion of a web site is typically expected to be encoded within a link that can be launched automatically when the user clicks on the link. Effectiveness: Limited
 Automated Static Analysis - Binary or Bytecode According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Bytecode Weakness Analysis - including disassembler + source code weakness analysis  Binary Weakness Analysis - including disassembler + source code weakness analysis    Effectiveness: SOAR Partial
 Manual Static Analysis - Binary or Bytecode According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies    Effectiveness: SOAR Partial
 Dynamic Analysis with Automated Results Interpretation According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Web Application Scanner    Effectiveness: High
 Dynamic Analysis with Manual Results Interpretation According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Fuzz Tester  Framework-based Fuzzer    Effectiveness: High
 Manual Static Analysis - Source Code According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Focused Manual Spotcheck - Focused manual analysis of source  Manual Source Code Review (not inspections)    Effectiveness: SOAR Partial
 Automated Static Analysis - Source Code According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Source code Weakness Analyzer  Context-configured Source Code Weakness Analyzer    Effectiveness: SOAR Partial
 Architecture or Design Review According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)  Formal Methods / Correct-By-Construction    Effectiveness: SOAR Partial","Potential Mitigations
Phase:  Architecture and DesignStrategy:  Libraries or Frameworks Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.  For example, use anti-CSRF packages such as the OWASP CSRFGuard. [REF-330]  Another example is the ESAPI Session Management control, which includes a component for CSRF. [REF-45]  
Phase:  ImplementationEnsure that the application is free of cross-site scripting issues (CWE-79), because most CSRF defenses can be bypassed using attacker-controlled script. 
Phase:  Architecture and DesignGenerate a unique nonce for each form, place the nonce into the form, and verify the nonce upon receipt of the form. Be sure that the nonce is not predictable (CWE-330). [REF-332] Note: Note that this can be bypassed using XSS (CWE-79). 
Phase:  Architecture and DesignIdentify especially dangerous operations. When the user performs a dangerous operation, send a separate confirmation request to ensure that the user intended to perform that operation. Note: Note that this can be bypassed using XSS (CWE-79). 
Phase:  Architecture and Design Use the ""double-submitted cookie"" method as described by Felten and Zeller:  When a user visits a site, the site should generate a pseudorandom value and set it as a cookie on the user's machine. The site should require every form submission to include this value as a form value and also as a cookie value. When a POST request is sent to the site, the request should only be considered valid if the form value and the cookie value are the same.  Because of the same-origin policy, an attacker cannot read or modify the value stored in the cookie. To successfully submit a form on behalf of the user, the attacker would have to correctly guess the pseudorandom value. If the pseudorandom value is cryptographically strong, this will be prohibitively difficult.  This technique requires Javascript, so it may not work for browsers that have Javascript disabled. [REF-331]  Note: Note that this can probably be bypassed using XSS (CWE-79), or when using web technologies that enable the attacker to read raw headers from HTTP requests. 
Phase:  Architecture and DesignDo not use the GET method for any request that triggers a state change. 
Phase:  ImplementationCheck the HTTP Referer header to see if the request originated from an expected page. This could break legitimate functionality, because users or proxies may have disabled sending the Referer for privacy reasons. Note: Note that this can be bypassed using XSS (CWE-79). An attacker could use XSS to generate a spoofed Referer, or to generate a malicious request from a page whose Referer would be allowed."
CWE-434,Unrestricted Upload of File with Dangerous Type,The product allows the attacker to upload or transfer files of dangerous types that can be automatically processed within the product's environment.,"Detection Methods
 Dynamic Analysis with Automated Results Interpretation According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Web Application Scanner  Web Services Scanner  Database Scanners    Effectiveness: SOAR Partial
 Dynamic Analysis with Manual Results Interpretation According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Fuzz Tester  Framework-based Fuzzer    Effectiveness: SOAR Partial
 Manual Static Analysis - Source Code According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Focused Manual Spotcheck - Focused manual analysis of source  Manual Source Code Review (not inspections)    Effectiveness: High
 Automated Static Analysis - Source Code According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Source code Weakness Analyzer  Context-configured Source Code Weakness Analyzer    Effectiveness: High
 Architecture or Design Review According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Formal Methods / Correct-By-Construction   Cost effective for partial coverage:   Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)    Effectiveness: High","Potential Mitigations
Phase:  Architecture and DesignGenerate a new, unique filename for an uploaded file instead of using the user-supplied filename, so that no external input is used at all.[REF-422] [REF-423] 
Phase:  Architecture and DesignStrategy:  Enforcement by ConversionWhen the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs. 
Phase:  Architecture and DesignConsider storing the uploaded files outside of the web document root entirely. Then, use other mechanisms to deliver the files dynamically. [REF-423] 
Phase:  ImplementationStrategy:  Input Validation Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""  Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.  For example, limiting filenames to alphanumeric characters can help to restrict the introduction of unintended file extensions.  
Phase:  Architecture and DesignDefine a very limited set of allowable extensions and only generate filenames that end in these extensions. Consider the possibility of XSS (CWE-79) before allowing .html or .htm file types. 
Phase:  ImplementationStrategy:  Input ValidationEnsure that only one extension is used in the filename. Some web servers, including some versions of Apache, may process files based on inner extensions so that ""filename.php.gif"" is fed to the PHP interpreter.[REF-422] [REF-423] 
Phase:  ImplementationWhen running on a web server that supports case-insensitive filenames, perform case-insensitive evaluations of the extensions that are provided. 
Phase:  Architecture and DesignFor any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server. 
Phase:  ImplementationDo not rely exclusively on sanity checks of file contents to ensure that the file is of the expected type and size. It may be possible for an attacker to hide code in some file segments that will still be executed by the server. For example, GIF images may contain a free-form comments field. 
Phase:  ImplementationDo not rely exclusively on the MIME content type or filename attribute when determining how to render a file. Validating the MIME content type and ensuring that it matches the extension is only a partial solution. 
Phases:  Architecture and Design; OperationStrategy:  Environment HardeningRun your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations. 
Phases:  Architecture and Design; OperationStrategy:  Sandbox or Jail Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.  Be careful to avoid CWE-243 and other weaknesses related to jails.  Effectiveness: LimitedNote: The effectiveness of this mitigation depends on the prevention capabilities of the specific sandbox or jail being used and might only help to reduce the scope of an attack, such as restricting the attacker to certain system calls or limiting the portion of the file system that can be accessed."
CWE-834,Missing Authorization,The product performs an iteration or loop without sufficiently limiting the number of times that the loop is executed.,"Detection Methods
 Dynamic Analysis with Manual Results Interpretation According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Fuzz Tester  Framework-based Fuzzer  Forced Path Execution    Effectiveness: SOAR Partial
 Manual Static Analysis - Source Code According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Focused Manual Spotcheck - Focused manual analysis of source  Manual Source Code Review (not inspections)    Effectiveness: SOAR Partial
 Automated Static Analysis - Source Code According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Context-configured Source Code Weakness Analyzer    Effectiveness: High
 Architecture or Design Review According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)    Effectiveness: High",
CWE-476,NULL Pointer Dereference,"A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.","Detection Methods
 Automated Dynamic AnalysisThis weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results. Effectiveness: Moderate
 Manual Dynamic AnalysisIdentify error conditions that are not likely to occur during normal usage and trigger them. For example, run the program under low memory conditions, run with insufficient privileges or permissions, interrupt a transaction before it is completed, or disable connectivity to basic network services such as DNS. Monitor the software for any unexpected behavior. If you trigger an unhandled exception or similar error that was discovered and handled by the application's environment, it may still indicate unexpected conditions that were not handled by the application itself. 
 Automated Static AnalysisAutomated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect ""sources"" (origins of input) with ""sinks"" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) Effectiveness: High","Potential Mitigations
Phase:  ImplementationIf all pointers that could have been modified are sanity-checked previous to use, nearly all NULL pointer dereferences can be prevented. 
Phase:  RequirementsThe choice could be made to use a language that is not susceptible to these issues. 
Phase:  ImplementationCheck the results of all functions that return a value and verify that the value is non-null before acting upon it. Effectiveness: ModerateNote: Checking the return value of the function will typically be sufficient, however beware of race conditions (CWE-362) in a concurrent environment. This solution does not handle the use of improperly initialized variables (CWE-665). 
Phase:  Architecture and DesignIdentify all variables and data stores that receive information from external sources, and apply input validation to make sure that they are only initialized to expected values. 
Phase:  ImplementationExplicitly initialize all your variables and other data stores, either during declaration or just before the first usage. 
Phase:  TestingUse automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible."
CWE-287,Improper Authentication,"When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.","Detection Methods
 Automated Static Analysis Automated static analysis is useful for detecting certain types of authentication. A tool may be able to analyze related configuration files, such as .htaccess in Apache web servers, or detect the usage of commonly-used authentication libraries.  Generally, automated static analysis tools have difficulty detecting custom authentication schemes. In addition, the software's design may include some functionality that is accessible to any user and does not require an established identity; an automated technique that detects the absence of authentication may report false positives.  Effectiveness: Limited
 Manual Static Analysis This weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session.  Manual static analysis is useful for evaluating the correctness of custom authentication mechanisms.  Effectiveness: HighNote: These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.
 Manual Static Analysis - Binary or Bytecode According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies    Effectiveness: SOAR Partial
 Dynamic Analysis with Automated Results Interpretation According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Web Application Scanner  Web Services Scanner  Database Scanners    Effectiveness: SOAR Partial
 Dynamic Analysis with Manual Results Interpretation According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Fuzz Tester  Framework-based Fuzzer    Effectiveness: SOAR Partial
 Manual Static Analysis - Source Code According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Manual Source Code Review (not inspections)    Effectiveness: SOAR Partial
 Automated Static Analysis - Source Code According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Source code Weakness Analyzer  Context-configured Source Code Weakness Analyzer    Effectiveness: SOAR Partial
 Automated Static Analysis According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Configuration Checker    Effectiveness: SOAR Partial
 Architecture or Design Review According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)  Formal Methods / Correct-By-Construction    Effectiveness: High","Potential Mitigations
Phase:  Architecture and DesignStrategy:  Libraries or FrameworksUse an authentication framework or library such as the OWASP ESAPI Authentication feature."
CWE-190,Integer Overflow or Wraparound,"The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.","Detection Methods
 Automated Static AnalysisThis weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives. Effectiveness: High
 Black BoxSometimes, evidence of this weakness can be detected using dynamic tools and techniques that interact with the product using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The product's operation may slow down, but it should not become unstable, crash, or generate incorrect results. Effectiveness: ModerateNote: Without visibility into the code, black box methods may not be able to sufficiently distinguish this weakness from others, requiring follow-up manual methods to diagnose the underlying problem.
 Manual Analysis This weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session.  Specifically, manual static analysis is useful for evaluating the correctness of allocation calculations. This can be useful for detecting overflow conditions (CWE-190) or similar weaknesses that might have serious security impacts on the program.  Effectiveness: HighNote: These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.
 Automated Static Analysis - Binary or Bytecode According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Bytecode Weakness Analysis - including disassembler + source code weakness analysis  Binary Weakness Analysis - including disassembler + source code weakness analysis    Effectiveness: High
 Dynamic Analysis with Manual Results Interpretation According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Fuzz Tester  Framework-based Fuzzer    Effectiveness: SOAR Partial
 Manual Static Analysis - Source Code According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Manual Source Code Review (not inspections)    Effectiveness: SOAR Partial
 Automated Static Analysis - Source Code According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Source code Weakness Analyzer  Context-configured Source Code Weakness Analyzer    Effectiveness: High
 Architecture or Design Review According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Formal Methods / Correct-By-Construction   Cost effective for partial coverage:   Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)    Effectiveness: High","Potential Mitigations
Phase:  RequirementsEnsure that all protocols are strictly defined, such that all out-of-bounds behavior can be identified simply, and require strict conformance to the protocol. 
Phase:  RequirementsStrategy:  Language Selection Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.  If possible, choose a language or compiler that performs automatic bounds checking.  
Phase:  Architecture and DesignStrategy:  Libraries or Frameworks Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.  Use libraries or frameworks that make it easier to handle numbers without unexpected consequences.  Examples include safe integer handling packages such as SafeInt (C++) or IntegerLib (C or C++). [REF-106]  
Phase:  ImplementationStrategy:  Input Validation Perform input validation on any numeric input by ensuring that it is within the expected range. Enforce that the input meets both the minimum and maximum requirements for the expected range.  Use unsigned integers where possible. This makes it easier to perform validation for integer overflows. When signed integers are required, ensure that the range check includes minimum values as well as maximum values.  
Phase:  Implementation Understand the programming language's underlying representation and how it interacts with numeric calculation (CWE-681). Pay close attention to byte size discrepancies, precision, signed/unsigned distinctions, truncation, conversion and casting between types, ""not-a-number"" calculations, and how the language handles numbers that are too large or too small for its underlying representation. [REF-7]  Also be careful to account for 32-bit, 64-bit, and other potential differences that may affect the numeric representation.  
Phase:  Architecture and DesignFor any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server. 
Phase:  ImplementationStrategy:  Compilation or Build HardeningExamine compiler warnings closely and eliminate problems with potential security implications, such as signed / unsigned mismatch in memory operations, or use of uninitialized variables. Even if the weakness is rarely exploitable, a single failure may lead to the compromise of the entire system."
CWE-502,Deserialization of Untrusted Data,The product deserializes untrusted data without sufficiently verifying that the resulting data will be valid.,"Detection Methods
 Automated Static AnalysisAutomated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect ""sources"" (origins of input) with ""sinks"" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) Effectiveness: High","Potential Mitigations
Phases:  Architecture and Design; ImplementationIf available, use the signing/sealing features of the programming language to assure that deserialized data has not been tainted. For example, a hash-based message authentication code (HMAC) could be used to ensure that data has not been modified. 
Phase:  ImplementationWhen deserializing data, populate a new object rather than just deserializing. The result is that the data flows through safe input validation and that the functions are safe. 
Phase:  ImplementationExplicitly define a final object() to prevent deserialization. 
Phases:  Architecture and Design; Implementation Make fields transient to protect them from deserialization.  An attempt to serialize and then deserialize a class containing transient fields will result in NULLs where the transient data should be. This is an excellent way to prevent time, environment-based, or sensitive variables from being carried over and used improperly.  
Phase:  ImplementationAvoid having unnecessary types or gadgets available that can be leveraged for malicious ends. This limits the potential for unintended or unauthorized types and gadgets to be leveraged by the attacker. Add only acceptable classes to an allowlist. Note: new gadgets are constantly being discovered, so this alone is not a sufficient mitigation."
CWE-77,Improper Neutralization of Special Elements used in a Command ('Command Injection'),"The product constructs all or part of a command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended command when it is sent to a downstream component.","Detection Methods
 Automated Static AnalysisAutomated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect ""sources"" (origins of input) with ""sinks"" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) Effectiveness: High","Potential Mitigations
Phase:  Architecture and DesignIf at all possible, use library calls rather than external processes to recreate the desired functionality. 
Phase:  ImplementationIf possible, ensure that all external commands called from the program are statically created. 
Phase:  ImplementationStrategy:  Input Validation Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""  Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.  
Phase:  OperationRun time: Run time policy enforcement may be used in an allowlist fashion to prevent use of any non-sanctioned commands. 
Phase:  System ConfigurationAssign permissions that prevent the user from accessing/opening privileged files."
CWE-119,Improper Restriction of Operations within the Bounds of a Memory Buffer,"The product performs operations on a memory buffer, but it can read from or write to a memory location that is outside of the intended boundary of the buffer.","Detection Methods
 Automated Static Analysis This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives.  Automated static analysis generally does not account for environmental considerations when reporting out-of-bounds memory operations. This can make it difficult for users to determine which warnings should be investigated first. For example, an analysis tool might report buffer overflows that originate from command line arguments in a program that is not expected to run with setuid or other special privileges.  Effectiveness: HighNote: Detection techniques for buffer-related errors are more mature than for most other weakness types.
 Automated Dynamic AnalysisThis weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results. 
 Automated Static Analysis - Binary or Bytecode According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Binary / Bytecode Quality Analysis  Bytecode Weakness Analysis - including disassembler + source code weakness analysis  Binary Weakness Analysis - including disassembler + source code weakness analysis    Effectiveness: SOAR Partial
 Manual Static Analysis - Binary or Bytecode According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies    Effectiveness: SOAR Partial
 Dynamic Analysis with Automated Results Interpretation According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Web Application Scanner  Web Services Scanner  Database Scanners    Effectiveness: SOAR Partial
 Dynamic Analysis with Manual Results Interpretation According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Fuzz Tester  Framework-based Fuzzer    Effectiveness: SOAR Partial
 Manual Static Analysis - Source Code According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Focused Manual Spotcheck - Focused manual analysis of source  Manual Source Code Review (not inspections)    Effectiveness: SOAR Partial
 Automated Static Analysis - Source Code According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Source code Weakness Analyzer  Context-configured Source Code Weakness Analyzer   Cost effective for partial coverage:   Source Code Quality Analyzer    Effectiveness: High
 Architecture or Design Review According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Formal Methods / Correct-By-Construction   Cost effective for partial coverage:   Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)    Effectiveness: High","Potential Mitigations
Phase:  RequirementsStrategy:  Language Selection Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.  
Phase:  Architecture and DesignStrategy:  Libraries or Frameworks Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.  Note: This is not a complete solution, since many buffer overflows are not related to strings."
CWE-798,Use of Hard-coded Credentials,"The product contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data.","Detection Methods
 Black BoxCredential storage in configuration files is findable using black box methods, but the use of hard-coded credentials for an incoming authentication routine typically involves an account that is not visible outside of the code. Effectiveness: Moderate
 Automated Static AnalysisAutomated white box techniques have been published for detecting hard-coded credentials for incoming authentication, but there is some expert disagreement regarding their effectiveness and applicability to a broad range of methods. 
 Manual Static AnalysisThis weakness may be detectable using manual code analysis. Unless authentication is decentralized and applied throughout the product, there can be sufficient time for the analyst to find incoming authentication routines and examine the program logic looking for usage of hard-coded credentials. Configuration files could also be analyzed. Note: These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.
 Manual Dynamic Analysis For hard-coded credentials in incoming authentication: use monitoring tools that examine the product's process as it interacts with the operating system and the network. This technique is useful in cases when source code is unavailable, if the product was not developed by you, or if you want to verify that the build phase did not introduce any new weaknesses. Examples include debuggers that directly attach to the running process; system-call tracing utilities such as truss (Solaris) and strace (Linux); system activity monitors such as FileMon, RegMon, Process Monitor, and other Sysinternals utilities (Windows); and sniffers and protocol analyzers that monitor network traffic.  Attach the monitor to the process and perform a login. Using call trees or similar artifacts from the output, examine the associated behaviors and see if any of them appear to be comparing the input to a fixed string or value.  
 Automated Static Analysis - Binary or Bytecode According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Bytecode Weakness Analysis - including disassembler + source code weakness analysis  Binary Weakness Analysis - including disassembler + source code weakness analysis    Effectiveness: SOAR Partial
 Manual Static Analysis - Binary or Bytecode According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies    Effectiveness: High
 Dynamic Analysis with Manual Results Interpretation According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Network Sniffer  Forced Path Execution    Effectiveness: SOAR Partial
 Manual Static Analysis - Source Code According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Focused Manual Spotcheck - Focused manual analysis of source  Manual Source Code Review (not inspections)    Effectiveness: High
 Automated Static Analysis - Source Code According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Source code Weakness Analyzer  Context-configured Source Code Weakness Analyzer    Effectiveness: High
 Automated Static Analysis According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Configuration Checker    Effectiveness: SOAR Partial
 Architecture or Design Review According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)  Formal Methods / Correct-By-Construction    Effectiveness: High","Potential Mitigations
Phase:  Architecture and Design For outbound authentication: store passwords, keys, and other credentials outside of the code in a strongly-protected, encrypted configuration file or database that is protected from access by all outsiders, including other local users on the same system. Properly protect the key (CWE-320). If you cannot use encryption to protect the file, then make sure that the permissions are as restrictive as possible [REF-7].  In Windows environments, the Encrypted File System (EFS) may provide some protection.  
Phase:  Architecture and DesignFor inbound authentication: Rather than hard-code a default username and password, key, or other authentication credentials for first time logins, utilize a ""first login"" mode that requires the user to enter a unique strong password or key. 
Phase:  Architecture and DesignIf the product must contain hard-coded credentials or they cannot be removed, perform access control checks and limit which entities can access the feature that requires the hard-coded credentials. For example, a feature might only be enabled through the system console instead of through a network connection. 
Phase:  Architecture and Design For inbound authentication using passwords: apply strong one-way hashes to passwords and store those hashes in a configuration file or database with appropriate access control. That way, theft of the file/database still requires the attacker to try to crack the password. When handling an incoming password during authentication, take the hash of the password and compare it to the saved hash.  Use randomly assigned salts for each separate hash that is generated. This increases the amount of computation that an attacker needs to conduct a brute-force attack, possibly limiting the effectiveness of the rainbow table method.  
Phase:  Architecture and Design For front-end to back-end connections: Three solutions are possible, although none are complete.   The first suggestion involves the use of generated passwords or keys that are changed automatically and must be entered at given time intervals by a system administrator. These passwords will be held in memory and only be valid for the time intervals.  Next, the passwords or keys should be limited at the back end to only performing actions valid for the front end, as opposed to having full access.  Finally, the messages sent should be tagged and checksummed with time sensitive values so as to prevent replay-style attacks."
CWE-918,Server-Side Request Forgery (SSRF),"The web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.","Detection Methods
 Automated Static AnalysisAutomated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect ""sources"" (origins of input) with ""sinks"" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) Effectiveness: High",
CWE-306,Missing Authentication for Critical Function,The product does not perform any authentication for functionality that requires a provable user identity or consumes a significant amount of resources.,"Detection Methods
 Manual Analysis This weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session.  Specifically, manual static analysis is useful for evaluating the correctness of custom authentication mechanisms.  Note: These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.
 Automated Static Analysis Automated static analysis is useful for detecting commonly-used idioms for authentication. A tool may be able to analyze related configuration files, such as .htaccess in Apache web servers, or detect the usage of commonly-used authentication libraries.  Generally, automated static analysis tools have difficulty detecting custom authentication schemes. In addition, the software's design may include some functionality that is accessible to any user and does not require an established identity; an automated technique that detects the absence of authentication may report false positives.  Effectiveness: Limited
 Manual Static Analysis - Binary or Bytecode According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies    Effectiveness: SOAR Partial
 Dynamic Analysis with Automated Results Interpretation According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Web Application Scanner  Web Services Scanner  Database Scanners    Effectiveness: SOAR Partial
 Dynamic Analysis with Manual Results Interpretation According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Host Application Interface Scanner  Fuzz Tester  Framework-based Fuzzer    Effectiveness: SOAR Partial
 Manual Static Analysis - Source Code According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Focused Manual Spotcheck - Focused manual analysis of source  Manual Source Code Review (not inspections)    Effectiveness: SOAR Partial
 Automated Static Analysis - Source Code According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Source code Weakness Analyzer  Context-configured Source Code Weakness Analyzer    Effectiveness: SOAR Partial
 Architecture or Design Review According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)  Formal Methods / Correct-By-Construction   Cost effective for partial coverage:   Attack Modeling    Effectiveness: High","Potential Mitigations
Phase:  Architecture and Design Divide the software into anonymous, normal, privileged, and administrative areas. Identify which of these areas require a proven user identity, and use a centralized authentication capability.  Identify all potential communication channels, or other means of interaction with the software, to ensure that all channels are appropriately protected. Developers sometimes perform authentication at the primary channel, but open up a secondary channel that is assumed to be private. For example, a login mechanism may be listening on one network port, but after successful authentication, it may open up a second port where it waits for the connection, but avoids authentication because it assumes that only the authenticated party will connect to the port.  In general, if the software or protocol allows a single session or user state to persist across multiple connections or channels, authentication and appropriate credential management need to be used throughout.  
Phase:  Architecture and DesignFor any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server. 
Phase:  Architecture and Design Where possible, avoid implementing custom authentication routines and consider using authentication capabilities as provided by the surrounding framework, operating system, or environment. These may make it easier to provide a clear separation between authentication tasks and authorization tasks.  In environments such as the World Wide Web, the line between authentication and authorization is sometimes blurred. If custom authentication routines are required instead of those provided by the server, then these routines must be applied to every single page, since these pages could be requested directly.  
Phase:  Architecture and DesignStrategy:  Libraries or Frameworks Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.  For example, consider using libraries with authentication capabilities such as OpenSSL or the ESAPI Authenticator [REF-45].  
Phases:  Implementation; System Configuration; OperationWhen storing data in the cloud (e.g., S3 buckets, Azure blobs, Google Cloud Storage, etc.), use the provider's controls to require strong authentication for users who should be allowed to access the data [REF-1297] [REF-1298] [REF-1302]."
CWE-362,Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition'),"The product contains a code sequence that can run concurrently with other code, and the code sequence requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence that is operating concurrently.","Detection Methods
 Black BoxBlack box methods may be able to identify evidence of race conditions via methods such as multiple simultaneous connections, which may cause the software to become instable or crash. However, race conditions with very narrow timing windows would not be detectable. 
 White BoxCommon idioms are detectable in white box analysis, such as time-of-check-time-of-use (TOCTOU) file operations (CWE-367), or double-checked locking (CWE-609). 
 Automated Dynamic Analysis This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.  Race conditions may be detected with a stress-test by calling the software simultaneously from a large number of threads or processes, and look for evidence of any unexpected behavior.  Insert breakpoints or delays in between relevant code statements to artificially expand the race window so that it will be easier to detect.  Effectiveness: Moderate
 Automated Static Analysis - Binary or Bytecode According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Bytecode Weakness Analysis - including disassembler + source code weakness analysis   Cost effective for partial coverage:   Binary Weakness Analysis - including disassembler + source code weakness analysis    Effectiveness: High
 Dynamic Analysis with Automated Results Interpretation According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Web Application Scanner  Web Services Scanner  Database Scanners    Effectiveness: SOAR Partial
 Dynamic Analysis with Manual Results Interpretation According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Framework-based Fuzzer   Cost effective for partial coverage:   Fuzz Tester  Monitored Virtual Environment - run potentially malicious code in sandbox / wrapper / virtual machine, see if it does anything suspicious    Effectiveness: High
 Manual Static Analysis - Source Code According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Manual Source Code Review (not inspections)   Cost effective for partial coverage:   Focused Manual Spotcheck - Focused manual analysis of source    Effectiveness: High
 Automated Static Analysis - Source Code According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Source code Weakness Analyzer  Context-configured Source Code Weakness Analyzer    Effectiveness: High
 Architecture or Design Review According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Formal Methods / Correct-By-Construction   Cost effective for partial coverage:   Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)    Effectiveness: High","Potential Mitigations
Phase:  Architecture and DesignIn languages that support it, use synchronization primitives. Only wrap these around critical code to minimize the impact on performance. 
Phase:  Architecture and DesignUse thread-safe capabilities such as the data access abstraction in Spring. 
Phase:  Architecture and Design Minimize the usage of shared resources in order to remove as much complexity as possible from the control flow and to reduce the likelihood of unexpected conditions occurring.  Additionally, this will minimize the amount of synchronization necessary and may even help to reduce the likelihood of a denial of service where an attacker may be able to repeatedly trigger a critical section (CWE-400).  
Phase:  ImplementationWhen using multithreading and operating on shared variables, only use thread-safe functions. 
Phase:  ImplementationUse atomic operations on shared variables. Be wary of innocent-looking constructs such as ""x++"". This may appear atomic at the code layer, but it is actually non-atomic at the instruction layer, since it involves a read, followed by a computation, followed by a write. 
Phase:  ImplementationUse a mutex if available, but be sure to avoid related weaknesses such as CWE-412. 
Phase:  ImplementationAvoid double-checked locking (CWE-609) and other implementation errors that arise when trying to avoid the overhead of synchronization. 
Phase:  ImplementationDisable interrupts or signals over critical parts of the code, but also make sure that the code does not go into a large or infinite loop. 
Phase:  ImplementationUse the volatile type modifier for critical variables to avoid unexpected compiler optimization or reordering. This does not necessarily solve the synchronization problem, but it can help. 
Phases:  Architecture and Design; OperationStrategy:  Environment HardeningRun your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations."
CWE-269,Improper Privilege Management,"The product does not properly assign, modify, track, or check privileges for an actor, creating an unintended sphere of control for that actor.","Detection Methods
 Automated Static AnalysisAutomated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect ""sources"" (origins of input) with ""sinks"" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) Effectiveness: High","Potential Mitigations
Phases:  Architecture and Design; OperationVery carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software. 
Phase:  Architecture and DesignStrategy:  Separation of PrivilegeFollow the principle of least privilege when assigning access rights to entities in a software system. 
Phase:  Architecture and DesignStrategy:  Separation of PrivilegeConsider following the principle of separation of privilege. Require multiple conditions to be met before permitting access to a system resource."
CWE-94,Improper Control of Generation of Code ('Code Injection'),"The product constructs all or part of a code segment using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the syntax or behavior of the intended code segment.","Detection Methods
 Automated Static AnalysisAutomated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect ""sources"" (origins of input) with ""sinks"" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) Effectiveness: High","Potential Mitigations
Phase:  Architecture and DesignRefactor your program so that you do not have to dynamically generate code. 
Phase:  Architecture and Design Run your code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which code can be executed by your product.  Examples include the Unix chroot jail and AppArmor. In general, managed code may provide some protection.  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of your application may still be subject to compromise.  Be careful to avoid CWE-243 and other weaknesses related to jails.  
Phase:  ImplementationStrategy:  Input Validation Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""  Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.  To reduce the likelihood of code injection, use stringent allowlists that limit which constructs are allowed. If you are dynamically constructing code that invokes a function, then verifying that the input is alphanumeric might be insufficient. An attacker might still be able to reference a dangerous function that you did not intend to allow, such as system(), exec(), or exit().  
Phase:  TestingUse automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible. 
Phase:  TestingUse dynamic tools and techniques that interact with the product using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The product's operation may slow down, but it should not become unstable, crash, or generate incorrect results. 
Phase:  OperationStrategy:  Compilation or Build HardeningRun the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184). 
Phase:  OperationStrategy:  Environment HardeningRun the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184). 
Phase:  Implementation For Python programs, it is frequently encouraged to use the ast.literal_eval() function instead of eval, since it is intentionally designed to avoid executing code. However, an adversary could still cause excessive memory or stack consumption via deeply nested structures [REF-1372], so the python documentation discourages use of ast.literal_eval() on untrusted data [REF-1373].  Effectiveness: Discouraged Common Practice"
CWE-863,Incorrect Authorization,"The product does not properly assign, modify, track, or check privileges for an actor, creating an unintended sphere of control for that actor.","Detection Methods
 Automated Static Analysis Automated static analysis is useful for detecting commonly-used idioms for authorization. A tool may be able to analyze related configuration files, such as .htaccess in Apache web servers, or detect the usage of commonly-used authorization libraries.  Generally, automated static analysis tools have difficulty detecting custom authorization schemes. Even if they can be customized to recognize these schemes, they might not be able to tell whether the scheme correctly performs the authorization in a way that cannot be bypassed or subverted by an attacker.  Effectiveness: Limited
 Automated Dynamic AnalysisAutomated dynamic analysis may not be able to find interfaces that are protected by authorization checks, even if those checks contain weaknesses. 
 Manual Analysis This weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session.  Specifically, manual static analysis is useful for evaluating the correctness of custom authorization mechanisms.  Effectiveness: ModerateNote: These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules. However, manual efforts might not achieve desired code coverage within limited time constraints.
 Manual Static Analysis - Binary or Bytecode According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies    Effectiveness: SOAR Partial
 Dynamic Analysis with Automated Results Interpretation According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Web Application Scanner  Web Services Scanner  Database Scanners    Effectiveness: SOAR Partial
 Dynamic Analysis with Manual Results Interpretation According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Host Application Interface Scanner  Fuzz Tester  Framework-based Fuzzer  Forced Path Execution  Monitored Virtual Environment - run potentially malicious code in sandbox / wrapper / virtual machine, see if it does anything suspicious    Effectiveness: SOAR Partial
 Manual Static Analysis - Source Code According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Focused Manual Spotcheck - Focused manual analysis of source  Manual Source Code Review (not inspections)    Effectiveness: SOAR Partial
 Automated Static Analysis - Source Code According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Context-configured Source Code Weakness Analyzer    Effectiveness: SOAR Partial
 Architecture or Design Review According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Formal Methods / Correct-By-Construction   Cost effective for partial coverage:   Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)    Effectiveness: High","Potential Mitigations
Phase:  Architecture and Design Divide the product into anonymous, normal, privileged, and administrative areas. Reduce the attack surface by carefully mapping roles with data and functionality. Use role-based access control (RBAC) [REF-229] to enforce the roles at the appropriate boundaries.  Note that this approach may not protect against horizontal authorization, i.e., it will not protect a user from attacking others with the same role.  
Phase:  Architecture and DesignEnsure that access control checks are performed related to the business logic. These checks may be different than the access control checks that are applied to more generic resources such as files, connections, processes, memory, and database records. For example, a database may restrict access for medical records to a specific database user, but each record might only be intended to be accessible to the patient and the patient's doctor [REF-7]. 
Phase:  Architecture and DesignStrategy:  Libraries or Frameworks Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.  For example, consider using authorization frameworks such as the JAAS Authorization Framework [REF-233] and the OWASP ESAPI Access Control feature [REF-45].  
Phase:  Architecture and Design For web applications, make sure that the access control mechanism is enforced correctly at the server side on every page. Users should not be able to access any unauthorized functionality or information by simply requesting direct access to that page.  One way to do this is to ensure that all pages containing sensitive information are not cached, and that all such pages restrict access to requests that are accompanied by an active and authenticated session token associated with a user who has the required permissions to access that page.  
Phases:  System Configuration; InstallationUse the access control capabilities of your operating system and server environment and define your access control lists accordingly. Use a ""default deny"" policy when defining these ACLs."
CWE-276,Incorrect Default Permissions,"The product constructs all or part of a code segment using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the syntax or behavior of the intended code segment.","Detection Methods
 Automated Static Analysis - Binary or Bytecode According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Inter-application Flow Analysis    Effectiveness: SOAR Partial
 Manual Static Analysis - Binary or Bytecode According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies    Effectiveness: SOAR Partial
 Dynamic Analysis with Automated Results Interpretation According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Host-based Vulnerability Scanners - Examine configuration for flaws, verifying that audit mechanisms work, ensure host configuration meets certain predefined criteria  Web Application Scanner  Web Services Scanner  Database Scanners    Effectiveness: SOAR Partial
 Dynamic Analysis with Manual Results Interpretation According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Host Application Interface Scanner   Cost effective for partial coverage:   Fuzz Tester  Framework-based Fuzzer  Automated Monitored Execution  Forced Path Execution    Effectiveness: High
 Manual Static Analysis - Source Code According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Manual Source Code Review (not inspections)   Cost effective for partial coverage:   Focused Manual Spotcheck - Focused manual analysis of source    Effectiveness: High
 Automated Static Analysis - Source Code According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Context-configured Source Code Weakness Analyzer    Effectiveness: SOAR Partial
 Automated Static Analysis According to SOAR, the following detection techniques may be useful:   Cost effective for partial coverage:   Configuration Checker    Effectiveness: SOAR Partial
 Architecture or Design Review According to SOAR, the following detection techniques may be useful:   Highly cost effective:   Formal Methods / Correct-By-Construction   Cost effective for partial coverage:   Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)    Effectiveness: High","Potential Mitigations
Phases:  Architecture and Design; OperationThe architecture needs to access and modification attributes for files to only those users who actually require those actions. 
Phase:  Architecture and DesignStrategy:  Separation of Privilege Compartmentalize the system to have ""safe"" areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area.  Ensure that appropriate compartmentalization is built into the system design, and the compartmentalization allows for and reinforces privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide the appropriate time to use privileges and the time to drop privileges."